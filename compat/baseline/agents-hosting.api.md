## API Report File for "@microsoft/agents-hosting"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Activity } from '@microsoft/agents-activity';
import { AdaptiveCardInvokeAction } from '@microsoft/agents-activity';
import { Application } from 'express';
import { Attachment } from '@microsoft/agents-activity';
import { AxiosInstance } from 'axios';
import { CardAction } from '@microsoft/agents-activity';
import { ChannelAccount } from '@microsoft/agents-activity';
import { ClientCitation } from '@microsoft/agents-activity';
import { ConversationParameters } from '@microsoft/agents-activity';
import { ConversationReference } from '@microsoft/agents-activity';
import { GetTokenOptions } from '@azure/core-auth';
import { InputHints } from '@microsoft/agents-activity';
import { JwtPayload } from 'jsonwebtoken';
import { NextFunction } from 'express';
import { Response as Response_2 } from 'express';
import { SensitivityUsageInfo } from '@microsoft/agents-activity';
import { TokenCredential } from '@azure/core-auth';
import { z } from 'zod';

// @public
export interface AadResourceUrls {
    resourceUrls: string[];
}

// @public (undocumented)
export const ACTION_INVOKE_NAME = "adaptiveCard/action";

// @public
export class ActivityHandler {
    protected static createInvokeResponse(body?: any): InvokeResponse;
    protected defaultNextEvent(context: TurnContext): () => Promise<void>;
    protected dispatchConversationUpdateActivity(context: TurnContext): Promise<void>;
    protected dispatchEventActivity(context: TurnContext): Promise<void>;
    protected dispatchMessageDeleteActivity(context: TurnContext): Promise<void>;
    protected dispatchMessageReactionActivity(context: TurnContext): Promise<void>;
    protected dispatchMessageUpdateActivity(context: TurnContext): Promise<void>;
    protected handle(context: TurnContext, type: string, onNext: () => Promise<void>): Promise<any>;
    protected readonly handlers: {
        [type: string]: AgentHandler[];
    };
    protected on(type: string, handler: AgentHandler): this;
    protected onAdaptiveCardInvoke(_context: TurnContext, _invokeValue: AdaptiveCardInvokeValue): Promise<AdaptiveCardInvokeResponse>;
    onConversationUpdate(handler: AgentHandler): this;
    protected onConversationUpdateActivity(context: TurnContext): Promise<void>;
    onDialog(handler: AgentHandler): this;
    onEndOfConversation(handler: AgentHandler): this;
    protected onEndOfConversationActivity(context: TurnContext): Promise<void>;
    onInstallationUpdate(handler: AgentHandler): this;
    protected onInstallationUpdateActivity(context: TurnContext): Promise<void>;
    onInstallationUpdateAdd(handler: AgentHandler): this;
    onInstallationUpdateRemove(handler: AgentHandler): this;
    protected onInvokeActivity(context: TurnContext): Promise<InvokeResponse>;
    onMembersAdded(handler: AgentHandler): this;
    onMembersRemoved(handler: AgentHandler): this;
    onMessage(handler: AgentHandler): this;
    protected onMessageActivity(context: TurnContext): Promise<void>;
    onMessageDelete(handler: AgentHandler): this;
    protected onMessageDeleteActivity(context: TurnContext): Promise<void>;
    onMessageReaction(handler: AgentHandler): this;
    protected onMessageReactionActivity(context: TurnContext): Promise<void>;
    onMessageUpdate(handler: AgentHandler): this;
    protected onMessageUpdateActivity(context: TurnContext): Promise<void>;
    onReactionsAdded(handler: AgentHandler): this;
    onReactionsRemoved(handler: AgentHandler): this;
    protected onSearchInvoke(_context: TurnContext, _invokeValue: SearchInvokeValue): Promise<SearchInvokeResponse>;
    onSignInInvoke(handler: AgentHandler): this;
    protected onSigninInvokeActivity(context: TurnContext): Promise<void>;
    onTurn(handler: AgentHandler): this;
    protected onTurnActivity(context: TurnContext): Promise<void>;
    onTyping(handler: AgentHandler): this;
    protected onTypingActivity(context: TurnContext): Promise<void>;
    protected onUnrecognizedActivity(context: TurnContext): Promise<void>;
    onUnrecognizedActivityType(handler: AgentHandler): this;
    run(context: TurnContext): Promise<void>;
}

// @public
export type ActivityImageType = 'avatar' | 'article';

// @public
export interface AdaptiveCard {
    // (undocumented)
    [key: string]: any;
    type: 'AdaptiveCard';
}

// @public
export enum AdaptiveCardActionExecuteResponseType {
    NEW_MESSAGE_FOR_ALL = 2,
    REPLACE_FOR_ALL = 1,
    REPLACE_FOR_INTERACTOR = 0
}

// @public
export interface AdaptiveCardAuthentication extends TokenExchangeInvokeRequest {
}

// @public
export interface AdaptiveCardInvokeResponse {
    statusCode: number;
    type: string;
    value: Record<string, unknown>;
}

// @public
export interface AdaptiveCardInvokeValue {
    action: AdaptiveCardInvokeAction;
    authentication: AdaptiveCardAuthentication;
    state: string;
}

// @public
export class AdaptiveCardsActions<TState extends TurnState> {
    constructor(app: AgentApplication<TState>);
    actionExecute<TData = Record<string, any>>(verb: string | RegExp | RouteSelector | (string | RegExp | RouteSelector)[], handler: (context: TurnContext, state: TState, data: TData) => Promise<AdaptiveCard | string>): AgentApplication<TState>;
    actionSubmit<TData = Record<string, any>>(verb: string | RegExp | RouteSelector | (string | RegExp | RouteSelector)[], handler: (context: TurnContext, state: TState, data: TData) => Promise<void>): AgentApplication<TState>;
    search(dataset: string | RegExp | RouteSelector | (string | RegExp | RouteSelector)[], handler: (context: TurnContext, state: TState, query: Query<AdaptiveCardsSearchParams>) => Promise<AdaptiveCardSearchResult[]>): AgentApplication<TState>;
}

// @public
export interface AdaptiveCardSearchResult {
    title: string;
    value: string;
}

// @public
export interface AdaptiveCardsOptions {
    actionExecuteResponseType?: AdaptiveCardActionExecuteResponseType;
    actionSubmitFilter?: string;
}

// @public
export interface AdaptiveCardsSearchParams {
    dataset: string;
    queryText: string;
}

// @public
export const adaptiveCardsSearchParamsZodSchema: z.ZodObject<{
    queryText: z.ZodString;
    dataset: z.ZodString;
}, "strip", z.ZodTypeAny, {
    queryText: string;
    dataset: string;
}, {
    queryText: string;
    dataset: string;
}>;

// @public
export class AgentApplication<TState extends TurnState> {
    constructor(options?: Partial<AgentApplicationOptions<TState>>);
    get adapter(): BaseAdapter;
    get adaptiveCards(): AdaptiveCardsActions<TState>;
    addRoute(selector: RouteSelector, handler: RouteHandler<TState>, isInvokeRoute?: boolean, rank?: number, authHandlers?: string[]): this;
    // (undocumented)
    protected readonly _afterTurn: ApplicationEventHandler<TState>[];
    get authorization(): Authorization;
    // (undocumented)
    protected readonly _beforeTurn: ApplicationEventHandler<TState>[];
    protected callEventHandlers(context: TurnContext, state: TState, handlers: ApplicationEventHandler<TState>[]): Promise<boolean>;
    protected continueConversationAsync(conversationReferenceOrContext: ConversationReference | TurnContext, logic: (context: TurnContext) => Promise<void>): Promise<void>;
    // (undocumented)
    protected readonly _extensions: AgentExtension<TState>[];
    onActivity(type: string | RegExp | RouteSelector | (string | RegExp | RouteSelector)[], handler: (context: TurnContext, state: TState) => Promise<void>, authHandlers?: string[], rank?: RouteRank): this;
    onConversationUpdate(event: ConversationUpdateEvents, handler: (context: TurnContext, state: TState) => Promise<void>, authHandlers?: string[], rank?: RouteRank): this;
    onError(handler: (context: TurnContext, error: Error) => Promise<void>): this;
    onMessage(keyword: string | RegExp | RouteSelector | (string | RegExp | RouteSelector)[], handler: (context: TurnContext, state: TState) => Promise<void>, authHandlers?: string[], rank?: RouteRank): this;
    onMessageReactionAdded(handler: (context: TurnContext, state: TState) => Promise<void>, rank?: RouteRank): this;
    onMessageReactionRemoved(handler: (context: TurnContext, state: TState) => Promise<void>, rank?: RouteRank): this;
    onSignInFailure(handler: (context: TurnContext, state: TurnState, id?: string) => Promise<void>): this;
    onSignInSuccess(handler: (context: TurnContext, state: TurnState, id?: string) => Promise<void>): this;
    onTurn(event: TurnEvents | TurnEvents[], handler: (context: TurnContext, state: TState) => Promise<boolean>): this;
    get options(): AgentApplicationOptions<TState>;
    // (undocumented)
    protected readonly _options: AgentApplicationOptions<TState>;
    registerExtension<T extends AgentExtension<TState>>(extension: T, regcb: (ext: T) => void): void;
    // (undocumented)
    protected readonly _routes: RouteList<TState>;
    run(turnContext: TurnContext): Promise<void>;
    runInternal(turnContext: TurnContext): Promise<boolean>;
    sendProactiveActivity(context: TurnContext | ConversationReference, activityOrText: string | Activity, speak?: string, inputHint?: string): Promise<ResourceResponse | undefined>;
    protected startLongRunningCall(context: TurnContext, handler: (context: TurnContext) => Promise<boolean>): Promise<boolean>;
    startTypingTimer(context: TurnContext): void;
    stopTypingTimer(): void;
}

// @public
export class AgentApplicationBuilder<TState extends TurnState = TurnState> {
    build(): AgentApplication<TState>;
    protected get options(): Partial<AgentApplicationOptions<TState>>;
    // (undocumented)
    protected _options: Partial<AgentApplicationOptions<TState>>;
    withAuthorization(authHandlers: AuthorizationHandlers): this;
    withStorage(storage: Storage_2): this;
    withTurnStateFactory(turnStateFactory: () => TState): this;
}

// @public
export interface AgentApplicationOptions<TState extends TurnState> {
    adapter?: CloudAdapter;
    adaptiveCardsOptions?: AdaptiveCardsOptions;
    agentAppId?: string;
    authorization?: AuthorizationHandlers;
    fileDownloaders?: InputFileDownloader<TState>[];
    headerPropagation?: HeaderPropagationDefinition;
    longRunningMessages: boolean;
    normalizeMentions?: boolean;
    removeRecipientMention?: boolean;
    startTypingTimer: boolean;
    storage?: Storage_2;
    transcriptLogger?: TranscriptLogger;
    turnStateFactory: () => TState;
}

// @public
export const AgentCallbackHandlerKey = "agentCallbackHandler";

// @public
export class AgentClient {
    constructor(agentConfigKey: string);
    agentClientConfig: AgentClientConfig;
    postActivity(activity: Activity, authConfig: AuthConfiguration, conversationState: ConversationState, context: TurnContext): Promise<string>;
}

// @public
export interface AgentClientConfig {
    clientId: string;
    endPoint: string;
    serviceUrl: string;
}

// @public
export class AgentExtension<TState extends TurnState> {
    constructor(channelId: string);
    addRoute(app: AgentApplication<TState>, routeSelector: RouteSelector, routeHandler: RouteHandler<TurnState>, isInvokeRoute?: boolean, rank?: number): void;
    channelId: string;
}

// @public
export type AgentHandler = (context: TurnContext, next: () => Promise<void>) => Promise<any>;

// @public
export class AgentState {
    constructor(storage: Storage_2, storageKey: StorageKeyFactory);
    clear(context: TurnContext): Promise<void>;
    createProperty<T = any>(name: string): AgentStatePropertyAccessor<T>;
    delete(context: TurnContext, customKey?: CustomKey): Promise<void>;
    get(context: TurnContext): any | undefined;
    load(context: TurnContext, force?: boolean, customKey?: CustomKey): Promise<any>;
    saveChanges(context: TurnContext, force?: boolean, customKey?: CustomKey): Promise<void>;
    // (undocumented)
    protected storage: Storage_2;
    // (undocumented)
    protected storageKey: StorageKeyFactory;
}

// @public
export class AgentStatePropertyAccessor<T = any> implements StatePropertyAccessor<T> {
    constructor(state: AgentState, name: string);
    delete(context: TurnContext, customKey?: CustomKey): Promise<void>;
    get(context: TurnContext, defaultValue?: T, customKey?: CustomKey): Promise<T>;
    // (undocumented)
    readonly name: string;
    set(context: TurnContext, value: T, customKey?: CustomKey): Promise<void>;
    // (undocumented)
    protected readonly state: AgentState;
}

// @public
export interface AnimationCard {
    aspect: string;
    autoloop: boolean;
    autostart: boolean;
    buttons: CardAction[];
    duration: string;
    image: ThumbnailUrl;
    media: MediaUrl[];
    shareable: boolean;
    subtitle: string;
    text: string;
    title: string;
    value: any;
}

// @public
export type ApplicationEventHandler<TState extends TurnState> = (context: TurnContext, state: TState) => Promise<boolean>;

// @public
export interface AppMemory {
    deleteValue(path: string): void;
    getValue<TValue = unknown>(path: string): TValue;
    hasValue(path: string): boolean;
    setValue(path: string, value: unknown): void;
}

// @public
export interface AppRoute<TState extends TurnState> {
    authHandlers?: string[];
    handler: RouteHandler<TState>;
    isInvokeRoute?: boolean;
    rank?: number;
    selector: RouteSelector;
}

// @public
export interface AttachmentData {
    name: string;
    originalBase64: Uint8Array;
    thumbnailBase64: Uint8Array;
    type: string;
}

// @public
export class AttachmentDownloader<TState extends TurnState = TurnState> implements InputFileDownloader<TState> {
    constructor(stateKey?: string);
    downloadAndStoreFiles(context: TurnContext, state: TState): Promise<void>;
    downloadFiles(context: TurnContext): Promise<InputFile[]>;
}

// @public
export interface AttachmentInfo {
    name: string;
    type: string;
    views: AttachmentView[];
}

// @public
export interface AttachmentView {
    size: number;
    viewId: string;
}

// @public
export interface AudioCard {
    aspect: string;
    autoloop: boolean;
    autostart: boolean;
    buttons: CardAction[];
    duration: string;
    image: ThumbnailUrl;
    media: MediaUrl[];
    shareable: boolean;
    subtitle: string;
    text: string;
    title: string;
    value: any;
}

// @public
export interface AuthConfiguration {
    authority?: string;
    certKeyFile?: string;
    certPemFile?: string;
    clientId: string;
    clientSecret?: string;
    connectionName?: string;
    FICClientId?: string;
    issuers: string[];
    tenantId?: string;
}

// @public
export interface AuthHandler {
    // (undocumented)
    cnxPrefix?: string;
    flow?: OAuthFlow;
    name?: string;
    text?: string;
    title?: string;
}

// @public
export class Authorization {
    constructor(storage: Storage_2, authHandlers: AuthorizationHandlers, userTokenClient: UserTokenClient);
    authHandlers: AuthorizationHandlers;
    beginOrContinueFlow(context: TurnContext, state: TurnState, authHandlerId: string, secRoute?: boolean): Promise<TokenResponse>;
    exchangeToken(context: TurnContext, scopes: string[], authHandlerId: string): Promise<TokenResponse>;
    getToken(context: TurnContext, authHandlerId: string): Promise<TokenResponse>;
    onSignInFailure(handler: (context: TurnContext, state: TurnState, authHandlerId?: string, errorMessage?: string) => Promise<void>): void;
    onSignInSuccess(handler: (context: TurnContext, state: TurnState, authHandlerId?: string) => Promise<void>): void;
    _signInFailureHandler: ((context: TurnContext, state: TurnState, authHandlerId?: string, errorMessage?: string) => Promise<void>) | null;
    _signInSuccessHandler: ((context: TurnContext, state: TurnState, authHandlerId?: string) => Promise<void>) | null;
    signOut(context: TurnContext, state: TurnState, authHandlerId?: string): Promise<void>;
}

// @public
export interface AuthorizationHandlers extends Record<string, AuthHandler> {
}

// @public
export const authorizeJWT: (authConfig: AuthConfiguration) => (req: Request_2, res: Response_2, next: NextFunction) => Promise<void>;

// @public
export interface AuthProvider {
    getAccessToken: (authConfig: AuthConfiguration, scope: string) => Promise<string>;
}

// @public
export abstract class BaseAdapter {
    readonly AgentIdentityKey: symbol;
    abstract authConfig: AuthConfiguration;
    authProvider: AuthProvider;
    readonly ConnectorClientKey: symbol;
    abstract continueConversation(reference: Partial<ConversationReference>, logic: (revocableContext: TurnContext) => Promise<void>): Promise<void>;
    abstract deleteActivity(context: TurnContext, reference: Partial<ConversationReference>): Promise<void>;
    abstract getAttachment(attachmentId: string, viewId: string): Promise<NodeJS.ReadableStream>;
    abstract getAttachmentInfo(attachmentId: string): Promise<AttachmentInfo>;
    protected middleware: MiddlewareSet;
    readonly OAuthScopeKey: symbol;
    get onTurnError(): (context: TurnContext, error: Error) => Promise<void>;
    set onTurnError(value: (context: TurnContext, error: Error) => Promise<void>);
    protected runMiddleware(context: TurnContext, next: (revocableContext: TurnContext) => Promise<void>): Promise<void>;
    abstract sendActivities(context: TurnContext, activities: Activity[]): Promise<ResourceResponse[]>;
    abstract updateActivity(context: TurnContext, activity: Activity): Promise<ResourceResponse | void>;
    abstract uploadAttachment(conversationId: string, attachmentData: AttachmentData): Promise<ResourceResponse>;
    use(...middlewares: Array<MiddlewareHandler | Middleware>): this;
    userTokenClient: UserTokenClient | null;
}

// @public
export interface CachedAgentState {
    hash: string;
    state: {
        [id: string]: any;
    };
}

// @public
export class CardFactory {
    static actions(actions: (CardAction | string)[] | undefined): CardAction[];
    static adaptiveCard(card: any): Attachment;
    static animationCard(title: string, media: (MediaUrl | string)[], buttons?: (CardAction | string)[], other?: Partial<AnimationCard>): Attachment;
    static audioCard(title: string, media: (MediaUrl | string)[], buttons?: (CardAction | string)[], other?: Partial<AudioCard>): Attachment;
    static contentTypes: any;
    static heroCard(title: string, text?: any, images?: any, buttons?: any, other?: Partial<HeroCard>): Attachment;
    static images(images: (CardImage | string)[] | undefined): CardImage[];
    static media(links: (MediaUrl | string)[] | undefined): MediaUrl[];
    static o365ConnectorCard(card: O365ConnectorCard): Attachment;
    static oauthCard(connectionName: string, title: string, text: string, signingResource: SignInResource): Attachment;
    static receiptCard(card: ReceiptCard): Attachment;
    static signinCard(title: string, url: string, text?: string): Attachment;
    static thumbnailCard(title: string, text?: any, images?: any, buttons?: any, other?: Partial<ThumbnailCard>): Attachment;
    static videoCard(title: string, media: (MediaUrl | string)[], buttons?: (CardAction | string)[], other?: Partial<VideoCard>): Attachment;
}

// @public
export interface CardImage {
    alt?: string;
    tap?: CardAction;
    url: string;
}

// @public
export interface Citation {
    content: string;
    filepath: string | null;
    title: string | null;
    url: string | null;
}

// @public
export interface Claim {
    // (undocumented)
    readonly type: string;
    // (undocumented)
    readonly value: string;
}

// @public
export class ClaimsIdentity {
    constructor(claims: Claim[], authenticationType?: string | boolean | undefined);
    // (undocumented)
    readonly claims: Claim[];
    getClaimValue(claimType: string): string | null;
    get isAuthenticated(): boolean;
}

// @public
export class CloudAdapter extends BaseAdapter {
    constructor(authConfig?: AuthConfiguration, authProvider?: AuthProvider, userTokenClient?: UserTokenClient);
    // (undocumented)
    authConfig: AuthConfiguration;
    connectorClient: ConnectorClient;
    continueConversation(reference: ConversationReference, logic: (revocableContext: TurnContext) => Promise<void>, isResponse?: Boolean): Promise<void>;
    protected createConnectorClient(serviceUrl: string, scope: string, headers?: HeaderPropagationCollection): Promise<ConnectorClient>;
    createConversationAsync(agentAppId: string, channelId: string, serviceUrl: string, audience: string, conversationParameters: ConversationParameters, logic: (context: TurnContext) => Promise<void>): Promise<void>;
    protected createCreateActivity(createdConversationId: string | undefined, channelId: string, serviceUrl: string, conversationParameters: ConversationParameters): Activity;
    createTurnContext(activity: Activity, logic: AgentHandler): TurnContext;
    // (undocumented)
    createTurnContextWithScope(activity: Activity, logic: AgentHandler, scope: string): Promise<TurnContext>;
    deleteActivity(context: TurnContext, reference: Partial<ConversationReference>): Promise<void>;
    getAttachment(attachmentId: string, viewId: string): Promise<NodeJS.ReadableStream>;
    getAttachmentInfo(attachmentId: string): Promise<AttachmentInfo>;
    process(request: Request_2, res: Response_2, logic: (context: TurnContext) => Promise<void>, headerPropagation?: HeaderPropagationDefinition): Promise<void>;
    protected processTurnResults(context: TurnContext): InvokeResponse | undefined;
    replyToActivity(activity: Activity): Promise<ResourceResponse>;
    protected resolveIfConnectorClientIsNeeded(activity: Activity): boolean;
    sendActivities(context: TurnContext, activities: Activity[]): Promise<ResourceResponse[]>;
    protected setConnectorClient(context: TurnContext): void;
    updateActivity(context: TurnContext, activity: Activity): Promise<ResourceResponse | void>;
    uploadAttachment(conversationId: string, attachmentData: AttachmentData): Promise<ResourceResponse>;
}

// @public
export const configureResponseController: (app: Application, adapter: CloudAdapter, agent: ActivityHandler, conversationState: ConversationState) => void;

// @public
export class ConnectorClient {
    protected constructor(axInstance: AxiosInstance);
    // (undocumented)
    get axiosInstance(): AxiosInstance;
    // (undocumented)
    protected readonly _axiosInstance: AxiosInstance;
    static createClientWithAuth(baseURL: string, authConfig: AuthConfiguration, authProvider: AuthProvider, scope: string, headers?: HeaderPropagationCollection): Promise<ConnectorClient>;
    createConversation(body: ConversationParameters): Promise<ConversationResourceResponse>;
    deleteActivity(conversationId: string, activityId: string): Promise<void>;
    getAttachment(attachmentId: string, viewId: string): Promise<NodeJS.ReadableStream>;
    getAttachmentInfo(attachmentId: string): Promise<AttachmentInfo>;
    // (undocumented)
    getConversationMember(userId: string, conversationId: string): Promise<ChannelAccount>;
    getConversations(continuationToken?: string): Promise<ConversationsResult>;
    replyToActivity(conversationId: string, activityId: string, body: Activity): Promise<ResourceResponse>;
    sendToConversation(conversationId: string, body: Activity): Promise<ResourceResponse>;
    updateActivity(conversationId: string, activityId: string, body: Activity): Promise<ResourceResponse>;
    uploadAttachment(conversationId: string, body: AttachmentData): Promise<ResourceResponse>;
}

// @public
export class ConsoleTranscriptLogger implements TranscriptLogger {
    logActivity(activity: Activity): void | Promise<void>;
}

// @public
export interface ConversationData {
    conversationReference: ConversationReference;
    nameRequested: boolean;
}

// @public
export interface ConversationMembers {
    id: string;
    members: ChannelAccount[];
}

// @public
export interface ConversationResourceResponse {
    activityId: string;
    id: string;
    serviceUrl: string;
}

// @public
export interface ConversationsResult {
    continuationToken: string;
    conversations: ConversationMembers[];
}

// @public
export class ConversationState extends AgentState {
    constructor(storage: Storage_2, namespace?: string);
}

// @public
export type ConversationUpdateEvents = 'membersAdded' | 'membersRemoved';

// @public
export interface CustomKey {
    channelId: string;
    conversationId: string;
}

// @public
export interface DefaultConversationState {
}

// @public
export interface DefaultUserState {
}

// @public
export type DeleteActivityHandler = (context: TurnContext, reference: ConversationReference, next: () => Promise<void>) => Promise<void>;

// @public
export interface Fact {
    key: string;
    value: string;
}

// @public
export class FileStorage implements Storage_2 {
    constructor(folder: string);
    delete(keys: string[]): Promise<void>;
    read(keys: string[]): Promise<StoreItem>;
    write(changes: StoreItem): Promise<void>;
}

// @public
export interface FlowState {
    absOauthConnectionName: string;
    continuationActivity?: Activity | null;
    // (undocumented)
    eTag?: string;
    flowExpires: number | undefined;
    flowStarted: boolean | undefined;
}

// @public
export const getProductInfo: () => string;

// @public
export class HeaderPropagation implements HeaderPropagationCollection {
    constructor(headers: Record<string, string | string[] | undefined>);
    // (undocumented)
    add(headers: Record<string, string>): void;
    // (undocumented)
    concat(headers: Record<string, string>): void;
    // (undocumented)
    get incoming(): Record<string, string>;
    // (undocumented)
    get outgoing(): Record<string, string>;
    // (undocumented)
    override(headers: Record<string, string>): void;
    // (undocumented)
    propagate(headers: string[]): void;
}

// @public
export interface HeaderPropagationCollection {
    add(headers: Record<string, string>): void;
    concat(headers: Record<string, string>): void;
    incoming: Record<string, string>;
    outgoing: Record<string, string>;
    override(headers: Record<string, string>): void;
    propagate(headers: string[]): void;
}

// @public
export interface HeaderPropagationDefinition {
    // (undocumented)
    (headers: HeaderPropagationCollection): void;
}

// @public
export interface HeroCard {
    buttons: CardAction[];
    images: CardImage[];
    subtitle: string;
    tap: CardAction;
    text: string;
    title: string;
}

// @public
export interface InputFile {
    content: Buffer;
    contentType: string;
    contentUrl?: string;
}

// @public
export interface InputFileDownloader<TState extends TurnState = TurnState> {
    downloadAndStoreFiles(context: TurnContext, state: TState): Promise<void>;
    downloadFiles(context: TurnContext): Promise<InputFile[]>;
}

// @public
export const INVOKE_RESPONSE_KEY: unique symbol;

// @public
export class InvokeException<T = unknown> extends Error {
    constructor(status: StatusCodes, response?: T | undefined);
    createInvokeResponse(): InvokeResponse;
}

// @public
export interface InvokeResponse<T = any> {
    body?: T;
    status: number;
}

// @public
export const loadAuthConfigFromEnv: (cnxName?: string) => AuthConfiguration;

// @public
export const loadPrevAuthConfigFromEnv: () => AuthConfiguration;

// @public
export interface MediaUrl {
    profile?: string;
    url: string;
}

// @public
export class MemoryStorage implements Storage_2 {
    constructor(memory?: {
        [k: string]: string;
    });
    delete(keys: string[]): Promise<void>;
    static getSingleInstance(): MemoryStorage;
    read(keys: string[]): Promise<StoreItem>;
    write(changes: StoreItem): Promise<void>;
}

// @public
export class MessageFactory {
    static attachment(attachment: Attachment, text?: string, speak?: string, inputHint?: InputHints | string): Activity;
    static carousel(attachments: Attachment[], text?: string, speak?: string, inputHint?: InputHints | string): Activity;
    static contentUrl(url: string, contentType: string, name?: string, text?: string, speak?: string, inputHint?: InputHints | string): Activity;
    static list(attachments: Attachment[], text?: string, speak?: string, inputHint?: InputHints | string): Activity;
    static suggestedActions(actions: Array<CardAction | string>, text?: string, speak?: string, inputHint?: InputHints | string): Activity;
    static text(text: string, speak?: string, inputHint?: InputHints | string): Activity;
}

// @public
export interface Middleware {
    // (undocumented)
    onTurn: (context: TurnContext, next: () => Promise<void>) => Promise<void>;
}

// @public
export type MiddlewareHandler = (context: TurnContext, next: () => Promise<void>) => Promise<void>;

// @public
export class MiddlewareSet implements Middleware {
    constructor(...middlewares: Array<MiddlewareHandler | Middleware>);
    onTurn(context: TurnContext, next: () => Promise<void>): Promise<void>;
    run(context: TurnContext, next: () => Promise<void>): Promise<void>;
    use(...middlewares: Array<MiddlewareHandler | Middleware>): this;
}

// @public
export class MsalTokenCredential implements TokenCredential {
    constructor(authConfig: AuthConfiguration);
    getToken(scopes: string[], options?: GetTokenOptions): Promise<{
        token: string;
        expiresOnTimestamp: number;
    }>;
}

// @public
export class MsalTokenProvider implements AuthProvider {
    // (undocumented)
    acquireTokenOnBehalfOf(authConfig: AuthConfiguration, scopes: string[], oboAssertion: string): Promise<string>;
    getAccessToken(authConfig: AuthConfiguration, scope: string): Promise<string>;
}

// @public
export interface O365ConnectorCard {
    potentialAction?: O365ConnectorCardActionBase[];
    sections?: O365ConnectorCardSection[];
    summary?: string;
    text?: string;
    themeColor?: string;
    title?: string;
}

// @public
export interface O365ConnectorCardActionBase {
    '@id'?: string;
    '@type'?: O365ConnectorCardActionType;
    name?: string;
}

// @public
export type O365ConnectorCardActionType = 'ViewAction' | 'OpenUri' | 'HttpPOST' | 'ActionCard';

// @public
export interface O365ConnectorCardFact {
    name?: string;
    value?: string;
}

// @public
export interface O365ConnectorCardImage {
    image?: string;
    title?: string;
}

// @public
export interface O365ConnectorCardSection {
    activityImage?: string;
    activityImageType?: ActivityImageType;
    activitySubtitle?: string;
    activityText?: string;
    activityTitle?: string;
    facts?: O365ConnectorCardFact[];
    images?: O365ConnectorCardImage[];
    markdown?: boolean;
    potentialAction?: O365ConnectorCardActionBase[];
    text?: string;
    title?: string;
}

// @public
export interface OAuthCard {
    buttons: CardAction[];
    connectionName: string;
    text: string;
    tokenExchangeResource: TokenExchangeResource;
    tokenPostResource: TokenPostResource;
}

// @public
export class OAuthFlow {
    constructor(storage: Storage_2, absOauthConnectionName: string, tokenClient: UserTokenClient, cardTitle?: string, cardText?: string);
    absOauthConnectionName: string;
    beginFlow(context: TurnContext): Promise<TokenResponse | undefined>;
    cardText: string;
    cardTitle: string;
    continueFlow(context: TurnContext): Promise<TokenResponse>;
    getFlowState(context: TurnContext): Promise<FlowState>;
    getUserToken(context: TurnContext): Promise<TokenResponse>;
    setFlowState(context: TurnContext, flowState: FlowState): Promise<void>;
    signOut(context: TurnContext): Promise<void>;
    state: FlowState;
    tokenExchangeId: string | null;
    userTokenClient: UserTokenClient;
}

// @public
export interface PagedResult<T> {
    continuationToken?: string;
    items: T[];
}

// @public
export interface Query<TParams extends Record<string, any>> {
    count: number;
    parameters: TParams;
    skip: number;
}

// @public
export interface ReceiptCard {
    buttons: CardAction[];
    facts: Fact[];
    items: ReceiptItem[];
    tap?: CardAction;
    tax: string;
    title: string;
    total: string;
    vat?: string;
}

// @public
export interface ReceiptItem {
    image: CardImage;
    price: string;
    quantity: number;
    subtitle?: string;
    tap?: CardAction;
    text?: string;
    title: string;
}

// @public
interface Request_2<Body extends Record<string, unknown> = Record<string, unknown>, Headers extends Record<string, string[] | string | undefined> = Record<string, string[] | string | undefined>> {
    body?: Body;
    headers: Headers;
    method?: string;
    user?: JwtPayload;
}
export { Request_2 as Request }

// @public
export interface ResourceResponse {
    id: string;
}

// @public
export type RouteHandler<TState extends TurnState> = (context: TurnContext, state: TState) => Promise<void>;

// @public (undocumented)
export class RouteList<TState extends TurnState> {
    // (undocumented)
    [Symbol.iterator](): Iterator<AppRoute<TState>>;
    // (undocumented)
    addRoute(selector: RouteSelector, handler: RouteHandler<TState>, isInvokeRoute?: boolean, rank?: number, authHandlers?: string[]): this;
}

// @public
export enum RouteRank {
    First = 0,
    Last,
    Unspecified
}

// @public
export type RouteSelector = Selector;

// @public
export interface SearchInvokeOptions {
    skip: number;
    top: number;
}

// @public
export interface SearchInvokeResponse extends AdaptiveCardInvokeResponse {
}

// @public
export interface SearchInvokeValue {
    context: any;
    kind: string;
    queryOptions: SearchInvokeOptions;
    queryText: string;
}

// @public
export type Selector = (context: TurnContext) => Promise<boolean>;

// @public
export type SendActivitiesHandler = (context: TurnContext, activities: Activity[], next: () => Promise<ResourceResponse[]>) => Promise<ResourceResponse[]>;

// @public
export interface SignInResource {
    signInLink: string;
    tokenExchangeResource: TokenExchangeResource;
    tokenPostResource: TokenPostResource;
}

// @public
export interface SignInState {
    completed?: boolean;
    continuationActivity?: Activity;
    handlerId?: string;
}

// @public
export interface StatePropertyAccessor<T = any> {
    delete(context: TurnContext): Promise<void>;
    get(context: TurnContext): Promise<T | undefined>;
    get(context: TurnContext, defaultValue: T): Promise<T>;
    set(context: TurnContext, value: T): Promise<void>;
}

// @public
export enum StatusCodes {
    BAD_GATEWAY = 502,
    BAD_REQUEST = 400,
    CONFLICT = 409,
    CREATED = 201,
    INTERNAL_SERVER_ERROR = 500,
    METHOD_NOT_ALLOWED = 405,
    MULTIPLE_CHOICES = 300,
    NOT_FOUND = 404,
    NOT_IMPLEMENTED = 501,
    OK = 200,
    PRECONDITION_FAILED = 412,
    UNAUTHORIZED = 401,
    UPGRADE_REQUIRED = 426
}

// @public
interface Storage_2 {
    delete: (keys: string[]) => Promise<void>;
    read: (keys: string[]) => Promise<StoreItem>;
    write: (changes: StoreItem) => Promise<void>;
}
export { Storage_2 as Storage }

// @public
export type StorageKeyFactory = (context: TurnContext) => string | Promise<string>;

// @public
export interface StoreItem {
    [key: string]: any;
    eTag?: string;
}

// @public
export interface StoreItems {
    [key: string]: any;
}

// @public
export class StreamingResponse {
    constructor(context: TurnContext);
    get citations(): ClientCitation[] | undefined;
    get delayInMs(): number;
    endStream(): Promise<void>;
    getMessage(): string;
    queueInformativeUpdate(text: string): void;
    queueTextChunk(text: string, citations?: Citation[]): void;
    setAttachments(attachments: Attachment[]): void;
    setCitations(citations: Citation[]): void;
    setDelayInMs(delayInMs: number): void;
    setFeedbackLoop(enableFeedbackLoop: boolean): void;
    setFeedbackLoopType(feedbackLoopType: 'default' | 'custom'): void;
    setGeneratedByAILabel(enableGeneratedByAILabel: boolean): void;
    setSensitivityLabel(sensitivityLabel: SensitivityUsageInfo): void;
    get streamId(): string | undefined;
    get updatesSent(): number;
}

// @public
export class TaskModuleAction implements CardAction {
    constructor(title: string, value: any);
    channelData?: unknown;
    displayText?: string | undefined;
    image?: string | undefined;
    imageAltText?: string | undefined;
    text?: string | undefined;
    title: string;
    type: string;
    value: unknown;
}

// @public
export interface ThumbnailCard {
    buttons: CardAction[];
    images: CardImage[];
    subtitle: string;
    tap: CardAction;
    text: string;
    title: string;
}

// @public
export interface ThumbnailUrl {
    alt?: string;
    url: string;
}

// @public
export interface TokenExchangeInvokeRequest {
    connectionName: string;
    id: string;
    token: string;
}

// @public
export interface TokenExchangeRequest {
    id?: string;
    token?: string;
    uri?: string;
}

// @public
export interface TokenExchangeResource {
    id?: string;
    providerId?: string;
    uri?: string;
}

// @public
export interface TokenOrSinginResourceResponse {
    signInResource: SignInResource;
    tokenResponse: TokenResponse;
}

// @public
export interface TokenPostResource {
    sasUrl?: string;
}

// @public
export interface TokenResponse {
    token: string | undefined;
}

// @public
export interface TokenStatus {
    channelId: string;
    connectionName: string;
    hasToken: boolean;
    serviceProviderDisplayName: string;
}

// @public
export interface TranscriptInfo {
    channelId: string;
    created: Date;
    id: string;
}

// @public
export interface TranscriptLogger {
    logActivity(activity: Activity): void | Promise<void>;
}

// @public
export class TranscriptLoggerMiddleware implements Middleware {
    constructor(logger: TranscriptLogger);
    onTurn(context: TurnContext, next: () => Promise<void>): Promise<void>;
}

// @public
export interface TranscriptStore extends TranscriptLogger {
    deleteTranscript(channelId: string, conversationId: string): Promise<void>;
    getTranscriptActivities(channelId: string, conversationId: string, continuationToken?: string, startDate?: Date): Promise<PagedResult<Activity>>;
    listTranscripts(channelId: string, continuationToken?: string): Promise<PagedResult<TranscriptInfo>>;
}

// @public
export class TurnContext {
    constructor(adapterOrContext: BaseAdapter, request: Activity);
    constructor(adapterOrContext: TurnContext);
    get activity(): Activity;
    get adapter(): BaseAdapter;
    readonly bufferedReplyActivities: Activity[];
    protected copyTo(context: TurnContext): void;
    deleteActivity(idOrReference: string | ConversationReference): Promise<void>;
    getAttachment(attachmentId: string, viewId: string): Promise<NodeJS.ReadableStream>;
    getAttachmentInfo(attachmentId: string): Promise<AttachmentInfo>;
    get locale(): string | undefined;
    set locale(value: string | undefined);
    onDeleteActivity(handler: DeleteActivityHandler): this;
    onSendActivities(handler: SendActivitiesHandler): this;
    onUpdateActivity(handler: UpdateActivityHandler): this;
    get responded(): boolean;
    set responded(value: boolean);
    sendActivities(activities: Activity[]): Promise<ResourceResponse[]>;
    sendActivity(activityOrText: string | Activity, speak?: string, inputHint?: string): Promise<ResourceResponse | undefined>;
    sendTraceActivity(name: string, value?: any, valueType?: string, label?: string): Promise<ResourceResponse | undefined>;
    // (undocumented)
    get streamingResponse(): StreamingResponse;
    get turnState(): TurnContextStateCollection;
    updateActivity(activity: Activity): Promise<void>;
    uploadAttachment(conversationId: string, attachmentData: AttachmentData): Promise<ResourceResponse>;
}

// @public
export class TurnContextStateCollection extends Map<any, any> {
    get<T = any>(key: any): T;
    get(key: any): any;
    pop(key: any): any;
    push(key: any, value: any): void;
}

// @public
export type TurnEvents = 'beforeTurn' | 'afterTurn';

// @public
export class TurnState<TConversationState = DefaultConversationState, TUserState = DefaultUserState> implements AppMemory {
    get conversation(): TConversationState;
    set conversation(value: TConversationState);
    deleteConversationState(): void;
    deleteUserState(): void;
    deleteValue(path: string): void;
    getScope(scope: string): TurnStateEntry | undefined;
    getValue<TValue = unknown>(path: string): TValue;
    hasValue(path: string): boolean;
    get isLoaded(): boolean;
    load(context: TurnContext, storage?: Storage_2, force?: boolean): Promise<boolean>;
    protected onComputeStorageKeys(context: TurnContext): Promise<Record<string, string>>;
    save(context: TurnContext, storage?: Storage_2): Promise<void>;
    setValue(path: string, value: unknown): void;
    get user(): TUserState;
    set user(value: TUserState);
}

// @public
export class TurnStateEntry {
    constructor(value?: Record<string, unknown>, storageKey?: string);
    delete(): void;
    get hasChanged(): boolean;
    get isDeleted(): boolean;
    replace(value?: Record<string, unknown>): void;
    get storageKey(): string | undefined;
    get value(): Record<string, unknown>;
}

// @public
export type UpdateActivityHandler = (context: TurnContext, activity: Activity, next: () => Promise<void>) => Promise<void>;

// @public
export class UserState extends AgentState {
    constructor(storage: Storage_2, namespace?: string);
}

// @public
export class UserTokenClient {
    constructor(msAppId: string);
    // (undocumented)
    client: AxiosInstance;
    exchangeTokenAsync(userId: string, connectionName: string, channelId: string, tokenExchangeRequest: TokenExchangeRequest): Promise<TokenResponse>;
    getAadTokens(userId: string, connectionName: string, channelId: string, resourceUrls: AadResourceUrls): Promise<Record<string, TokenResponse>>;
    getSignInResource(msAppId: string, connectionName: string, conversation: ConversationReference, relatesTo?: ConversationReference): Promise<SignInResource>;
    getTokenOrSignInResource(userId: string, connectionName: string, channelId: string, conversation: ConversationReference, relatesTo: ConversationReference, code: string, finalRedirect?: string, fwdUrl?: string): Promise<TokenOrSinginResourceResponse>;
    getTokenStatus(userId: string, channelId: string, include?: string): Promise<TokenStatus[]>;
    getUserToken(connectionName: string, channelId: string, userId: string, code?: string): Promise<TokenResponse>;
    signOut(userId: string, connectionName: string, channelId: string): Promise<void>;
    // (undocumented)
    updateAuthToken(token: string): void;
}

// @public
export interface VideoCard {
    aspect: string;
    autoloop: boolean;
    autostart: boolean;
    buttons: CardAction[];
    duration: string;
    image: ThumbnailUrl;
    media: MediaUrl[];
    shareable: boolean;
    subtitle: string;
    text: string;
    title: string;
    value: any;
}

// (No @packageDocumentation comment for this package)

```
