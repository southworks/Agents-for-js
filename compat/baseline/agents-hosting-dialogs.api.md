## API Report File for "@microsoft/agents-hosting-dialogs"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Activity } from '@microsoft/agents-activity';
import { AgentState } from '@microsoft/agents-hosting';
import { AgentStatePropertyAccessor } from '@microsoft/agents-hosting';
import { Attachment } from '@microsoft/agents-activity';
import { CardAction } from '@microsoft/agents-activity';
import { ConversationState } from '@microsoft/agents-hosting';
import { TurnContext } from '@microsoft/agents-hosting';
import { TurnContextStateCollection } from '@microsoft/agents-hosting';
import { UserState } from '@microsoft/agents-hosting';
import * as z from 'zod';

// @public
export class ActivityPrompt extends Dialog {
    constructor(dialogId: string, validator: PromptValidator<Activity>);
    beginDialog(dialogContext: DialogContext, options: PromptOptions): Promise<DialogTurnResult>;
    continueDialog(dialogContext: DialogContext): Promise<DialogTurnResult>;
    protected onPrompt(context: TurnContext, state: object, options: PromptOptions, isRetry: boolean): Promise<void>;
    protected onRecognize(context: TurnContext, _state: object, _options: PromptOptions): Promise<PromptRecognizerResult<Activity>>;
    repromptDialog(context: TurnContext, instance: DialogInstance): Promise<void>;
    resumeDialog(dialogContext: DialogContext, _reason: DialogReason, _result?: any): Promise<DialogTurnResult>;
}

// @public
export abstract class AgentComponent {
    abstract configureServices(services: ServiceCollection, configuration: Configuration): void;
    static z: z.ZodType<AgentComponent, z.ZodTypeDef, AgentComponent>;
}

// @public
export class AgentStateMemoryScope extends MemoryScope {
    constructor(name: string);
    delete(_dialogContext: DialogContext): Promise<void>;
    getMemory(dialogContext: DialogContext): object;
    load(dialogContext: DialogContext, force?: boolean): Promise<void>;
    saveChanges(dialogContext: DialogContext, force?: boolean): Promise<void>;
    setMemory(dialogContext: DialogContext, _memory: object): void;
    // (undocumented)
    protected stateKey: string;
}

// @public
export class AliasPathResolver implements PathResolver {
    constructor(alias: string, prefix: string, postfix?: string);
    transformPath(path: string): string;
}

// @public
export class AtAtPathResolver extends AliasPathResolver {
    constructor();
}

// @public
export class AtPathResolver extends AliasPathResolver {
    constructor();
    transformPath(path: string): string;
}

// @public
export class AttachmentPrompt extends Prompt<Attachment[]> {
    constructor(dialogId: string, validator?: PromptValidator<Attachment[]>);
    protected onPrompt(context: TurnContext, state: any, options: PromptOptions, isRetry: boolean): Promise<void>;
    protected onRecognize(context: TurnContext, _state: any, _options: PromptOptions): Promise<PromptRecognizerResult<Attachment[]>>;
}

// @public
export interface Choice {
    action?: CardAction;
    synonyms?: string[];
    value: string;
}

// @public
export interface ChoiceDefaultsChoicePrompt {
    [locale: string]: ChoiceFactoryOptions;
}

// @public
export interface ChoiceDefaultsConfirmPrompt {
    [locale: string]: {
        choices: (string | Choice)[];
        options: ChoiceFactoryOptions;
    };
}

// @public
export class ChoiceFactory {
    static forChannel(channelOrContext: string | TurnContext, choices: (string | Choice)[], text?: string, speak?: string, options?: ChoiceFactoryOptions): Activity;
    static inline(choices: (string | Choice)[], text?: string, speak?: string, options?: ChoiceFactoryOptions): Activity;
    static list(choices: (string | Choice)[], text?: string, speak?: string, options?: ChoiceFactoryOptions): Activity;
    // (undocumented)
    static readonly MAX_ACTION_TITLE_LENGTH = 20;
    static toChoices(choices: (string | Choice)[] | undefined): Choice[];
}

// @public
export interface ChoiceFactoryOptions {
    includeNumbers?: boolean;
    inlineOr?: string;
    inlineOrMore?: string;
    inlineSeparator?: string;
}

// @public
export class ChoicePrompt extends Prompt<FoundChoice> {
    constructor(dialogId: string, validator?: PromptValidator<FoundChoice>, defaultLocale?: string, choiceDefaults?: ChoiceDefaultsChoicePrompt);
    choiceOptions: ChoiceFactoryOptions | undefined;
    defaultLocale: string | undefined;
    protected onPrompt(context: TurnContext, state: any, options: PromptOptions, isRetry: boolean): Promise<void>;
    protected onRecognize(context: TurnContext, state: any, options: PromptOptions): Promise<PromptRecognizerResult<FoundChoice>>;
    recognizerOptions: FindChoicesOptions | undefined;
    style: ListStyle;
}

// @public
export class ClassMemoryScope extends MemoryScope {
    constructor(name?: string);
    getMemory(dialogContext: DialogContext): object;
    protected onFindDialog(dialogContext: DialogContext): Dialog | undefined;
}

// @public
export class ComponentDialog<O extends object = {}> extends DialogContainer<O> {
    addDialog(dialog: Dialog): this;
    beginDialog(outerDialogContext: DialogContext, options?: O): Promise<DialogTurnResult>;
    continueDialog(outerDialogContext: DialogContext): Promise<DialogTurnResult>;
    createChildContext(outerDialogContext: DialogContext): DialogContext;
    protected endComponent(outerDC: DialogContext, result: any): Promise<DialogTurnResult>;
    endDialog(context: TurnContext, instance: DialogInstance, reason: DialogReason): Promise<void>;
    protected initialDialogId: string;
    protected onBeginDialog(innerDialogContext: DialogContext, options?: O): Promise<DialogTurnResult>;
    protected onContinueDialog(innerDC: DialogContext): Promise<DialogTurnResult>;
    protected onEndDialog(_context: TurnContext, _instance: DialogInstance, _reason: DialogReason): Promise<void>;
    protected onRepromptDialog(_context: TurnContext, _instance: DialogInstance): Promise<void>;
    repromptDialog(context: TurnContext, instance: DialogInstance): Promise<void>;
    resumeDialog(outerDialogContext: DialogContext, _reason: DialogReason, _result?: any): Promise<DialogTurnResult>;
}

// @public
export interface ComponentMemoryScopes {
    // (undocumented)
    getMemoryScopes(): MemoryScope[];
}

// @public
export interface ComponentPathResolvers {
    // (undocumented)
    getPathResolvers(): PathResolver[];
}

// @public
export abstract class Configurable {
    configure(config: Record<string, unknown>): this;
    getConverter(_property: string): Converter | ConverterFactory;
}

// @public
export interface Configuration {
    // (undocumented)
    get<T = unknown>(path?: string[]): T | undefined;
    // (undocumented)
    set(path: string[], value: unknown): void;
}

// @public
export class ConfirmPrompt extends Prompt<boolean> {
    constructor(dialogId: string, validator?: PromptValidator<boolean>, defaultLocale?: string, choiceDefaults?: ChoiceDefaultsConfirmPrompt);
    choiceOptions: ChoiceFactoryOptions | undefined;
    confirmChoices: (string | Choice)[] | undefined;
    defaultLocale: string | undefined;
    protected onPrompt(context: TurnContext, state: any, options: PromptOptions, isRetry: boolean): Promise<void>;
    protected onRecognize(context: TurnContext, _state: any, _options: PromptOptions): Promise<PromptRecognizerResult<boolean>>;
    style: ListStyle;
}

// @public
export class ConversationMemoryScope extends AgentStateMemoryScope {
    constructor();
    // (undocumented)
    protected stateKey: string;
}

// @public
export interface Converter<From = unknown, To = unknown> {
    // (undocumented)
    convert(value: From | To): To;
}

// @public
export type ConverterFactory<From = unknown, To = unknown> = {
    new (...args: unknown[]): Converter<From, To>;
};

// @public
export class DateTimePrompt extends Prompt<DateTimeResolution[]> {
    constructor(dialogId: string, validator?: PromptValidator<DateTimeResolution[]>, defaultLocale?: string);
    defaultLocale: string | undefined;
    protected onPrompt(context: TurnContext, state: any, options: PromptOptions, isRetry: boolean): Promise<void>;
    protected onRecognize(context: TurnContext, _state: any, _options: PromptOptions): Promise<PromptRecognizerResult<DateTimeResolution[]>>;
}

// @public
export interface DateTimeResolution {
    timex: string;
    type: string;
    value: string;
}

// @public
export function defaultTokenizer(text: string, _locale?: string): Token[];

// @public
export type DependencyFactory<Type, Dependencies, Initial extends boolean> = (dependencies: Dependencies, initialValue: Initial extends true ? Type : Type | undefined) => Type;

// @public
export abstract class Dialog<O extends object = {}> extends Configurable {
    constructor(dialogId?: string);
    abstract beginDialog(dc: DialogContext, options?: O): Promise<DialogTurnResult>;
    continueDialog(dc: DialogContext): Promise<DialogTurnResult>;
    endDialog(_context: TurnContext, _instance: DialogInstance, _reason: DialogReason): Promise<void>;
    static EndOfTurn: DialogTurnResult;
    getVersion(): string;
    get id(): string;
    set id(value: string);
    protected onComputeId(): string;
    onDialogEvent(dialogContext: DialogContext, event: DialogEvent): Promise<boolean>;
    protected onPostBubbleEvent(_dc: DialogContext, _e: DialogEvent): Promise<boolean>;
    protected onPreBubbleEvent(_dc: DialogContext, _e: DialogEvent): Promise<boolean>;
    repromptDialog(_context: TurnContext, _instance: DialogInstance): Promise<void>;
    resumeDialog(dc: DialogContext, reason: DialogReason, result?: any): Promise<DialogTurnResult>;
}

// @public
export class DialogClassMemoryScope extends ClassMemoryScope {
    constructor();
    protected onFindDialog(dialogContext: DialogContext): Dialog | undefined;
}

// @public
export interface DialogConfiguration {
    id?: string;
}

// @public
export abstract class DialogContainer<O extends object = {}> extends Dialog<O> {
    protected checkForVersionChange(dialogContext: DialogContext): Promise<void>;
    abstract createChildContext(dialogContext: DialogContext): DialogContext | undefined;
    readonly dialogs: DialogSet;
    findDialog(dialogId: string): Dialog | undefined;
    protected getInternalVersion(): string;
    onDialogEvent(dialogContext: DialogContext, event: DialogEvent): Promise<boolean>;
}

// @public
export class DialogContext {
    constructor(dialogs: DialogSet, contextOrDialogContext: TurnContext, state: DialogState);
    constructor(dialogs: DialogSet, contextOrDialogContext: DialogContext, state: DialogState);
    get activeDialog(): DialogInstance | undefined;
    beginDialog(dialogId: string, options?: object): Promise<DialogTurnResult>;
    cancelAllDialogs(cancelParents?: boolean, eventName?: string, eventValue?: any): Promise<DialogTurnResult>;
    get child(): DialogContext | undefined;
    context: TurnContext;
    continueDialog(): Promise<DialogTurnResult>;
    get dialogManager(): DialogManager;
    dialogs: DialogSet;
    emitEvent(name: string, value?: any, bubble?: boolean, fromLeaf?: boolean): Promise<boolean>;
    endDialog(result?: any): Promise<DialogTurnResult>;
    findDialog(dialogId: string): Dialog | undefined;
    getLocale(): string;
    parent: DialogContext | undefined;
    prompt(dialogId: string, promptOrOptions: string | Partial<Activity> | PromptOptions): Promise<DialogTurnResult>;
    prompt(dialogId: string, promptOrOptions: string | Partial<Activity> | PromptOptions, choices: (string | Choice)[]): Promise<DialogTurnResult>;
    replaceDialog(dialogId: string, options?: object): Promise<DialogTurnResult>;
    repromptDialog(): Promise<void>;
    services: TurnContextStateCollection;
    stack: DialogInstance[];
    state: DialogStateManager;
}

// @public
export class DialogContextError extends Error {
    constructor(error: Error | string, dialogContext: DialogContext);
    readonly dialogContext: {
        activeDialog?: string;
        parent?: string;
        stack: DialogInstance[];
    };
    // (undocumented)
    readonly error: Error | string;
}

// @public
export class DialogContextMemoryScope extends MemoryScope {
    constructor();
    getMemory(dialogContext: DialogContext): Record<'stack' | 'activeDialog' | 'parent', unknown>;
}

// @public
export interface DialogDependencies {
    getDependencies(): Dialog[];
}

// @public
export interface DialogEvent {
    bubble: boolean;
    name: string;
    value?: any;
}

// @public
export class DialogEvents {
    static readonly activityReceived = "activityReceived";
    static readonly beginDialog = "beginDialog";
    static readonly cancelDialog = "cancelDialog";
    static readonly error = "error";
    static readonly repromptDialog = "repromptDialog";
    static readonly versionChanged = "versionChanged";
}

// @public
export interface DialogInstance<T = any> {
    id: string;
    state: T;
    version?: string;
}

// @public
export class DialogManager extends Configurable {
    constructor(rootDialog?: Dialog, dialogStateProperty?: string);
    configure(config: Partial<DialogManagerConfiguration>): this;
    // (undocumented)
    conversationState: ConversationState;
    // (undocumented)
    dialogs: DialogSet;
    // (undocumented)
    expireAfter?: number;
    get initialTurnState(): TurnContextStateCollection;
    onTurn(context: TurnContext): Promise<DialogManagerResult>;
    set rootDialog(value: Dialog);
    get rootDialog(): Dialog;
    // (undocumented)
    stateConfiguration?: DialogStateManagerConfiguration;
    // (undocumented)
    userState?: UserState;
}

// @public
export interface DialogManagerConfiguration {
    conversationState: AgentState;
    expireAfter?: number;
    rootDialog: Dialog;
    stateConfiguration?: DialogStateManagerConfiguration;
    userState?: UserState;
}

// @public
export interface DialogManagerResult {
    turnResult: DialogTurnResult;
}

// @public
export class DialogMemoryScope extends MemoryScope {
    constructor();
    getMemory(dialogContext: DialogContext): object;
    setMemory(dialogContext: DialogContext, memory: object): void;
}

// @public
export class DialogPath {
    static readonly defaultOperation: string;
    static readonly eventCounter: string;
    static readonly expectedProperties: string;
    static readonly lastEvent: string;
    static readonly lastIntent: string;
    static readonly lastTriggerEvent: string;
    static readonly requiredProperties: string;
    static readonly retries: string;
}

// @public
export enum DialogReason {
    beginCalled = "beginCalled",
    cancelCalled = "cancelCalled",
    continueCalled = "continueCalled",
    endCalled = "endCalled",
    nextCalled = "nextCalled",
    replaceCalled = "replaceCalled"
}

// @public
export class DialogsAgentComponent extends AgentComponent {
    // (undocumented)
    configureServices(services: ServiceCollection, configuration: Configuration): void;
}

// @public
export class DialogSet {
    constructor(dialogState?: AgentStatePropertyAccessor<DialogState>);
    add<T extends Dialog>(dialog: T): this;
    createContext(context: TurnContext): Promise<DialogContext>;
    find(dialogId: string): Dialog | undefined;
    getDialogs(): Dialog[];
    getVersion(): string;
}

// @public
export interface DialogState {
    dialogStack: DialogInstance[];
}

// @public
export class DialogStateManager {
    constructor(dc: DialogContext, configuration?: DialogStateManagerConfiguration);
    anyPathChanged(counter: number, paths: string[]): boolean;
    configuration: DialogStateManagerConfiguration;
    deleteScopesMemory(name: string): Promise<void>;
    deleteValue(pathExpression: string): void;
    getMemorySnapshot(): object;
    getValue<T = any>(pathExpression: string, defaultValue?: T | (() => T)): T;
    loadAllScopes(): Promise<void>;
    parsePath(pathExpression: string, allowNestedPaths?: boolean): (string | number)[];
    saveAllChanges(): Promise<void>;
    setValue(pathExpression: string, value: any): void;
    trackPaths(paths: string[]): string[];
    transformPath(pathExpression: string): string;
    version(): string;
}

// @public
export interface DialogStateManagerConfiguration {
    readonly memoryScopes: MemoryScope[];
    readonly pathResolvers: PathResolver[];
}

// @public
export interface DialogTurnResult<T = any> {
    parentEnded?: boolean;
    result?: T;
    status: DialogTurnStatus;
}

// @public
export class DialogTurnStateConstants {
    static configuration: symbol;
    static dialogManager: symbol;
    static queueStorage: symbol;
}

// @public
export enum DialogTurnStatus {
    cancelled = "cancelled",
    complete = "complete",
    completeAndWait = "completeAndWait",
    empty = "empty",
    waiting = "waiting"
}

// @public
export class DollarPathResolver extends AliasPathResolver {
    constructor();
}

// @public
export type Factory<Type, Initial extends boolean> = (initialValue: Initial extends true ? Type : Type | undefined) => Type;

// @public
export function findChoices(utterance: string, choices: (string | Choice)[], options?: FindChoicesOptions): ModelResult<FoundChoice>[];

// @public (undocumented)
export interface FindChoicesOptions extends FindValuesOptions {
    noAction?: boolean;
    noValue?: boolean;
    recognizeNumbers?: boolean;
    recognizeOrdinals?: boolean;
}

// @internal
export function findValues(utterance: string, values: SortedValue[], options?: FindValuesOptions): ModelResult<FoundValue>[];

// @public
export interface FindValuesOptions {
    allowPartialMatches?: boolean;
    locale?: string;
    maxTokenDistance?: number;
    tokenizer?: TokenizerFunction;
}

// @public
export interface FoundChoice {
    index: number;
    score: number;
    synonym?: string;
    value: string;
}

// @public
export interface FoundValue {
    index: number;
    score: number;
    value: string;
}

// @public
export const getTopScoringIntent: (result: RecognizerResult) => {
    intent: string;
    score: number;
};

// @public
export class HashPathResolver extends AliasPathResolver {
    constructor();
}

// @public
export interface IntentScore {
    [key: string]: unknown;
    score?: number;
}

// @public
export function isComponentMemoryScopes(component: unknown): component is ComponentMemoryScopes;

// @public
export function isComponentPathResolvers(component: unknown): component is ComponentPathResolvers;

// @public
export enum ListStyle {
    auto = 1,
    heroCard = 5,
    inline = 2,
    list = 3,
    none = 0,
    suggestedAction = 4
}

// @public
export abstract class MemoryScope {
    constructor(name: string, includeInSnapshot?: boolean);
    delete(_dialogContext: DialogContext): Promise<void>;
    abstract getMemory(dialogContext: DialogContext): object;
    // (undocumented)
    readonly includeInSnapshot: boolean;
    load(_dialogContext: DialogContext): Promise<void>;
    // (undocumented)
    readonly name: string;
    saveChanges(_dialogContext: DialogContext): Promise<void>;
    setMemory(_dialogContext: DialogContext, _memory: object): void;
}

// @public
export interface ModelResult<T extends Record<string, any> = {}> {
    end: number;
    resolution: T;
    start: number;
    text: string;
    typeName: string;
}

// @public
export const noOpConfiguration: Configuration;

// @public
export class NumberPrompt extends Prompt<number> {
    constructor(dialogId: string, validator?: PromptValidator<number>, defaultLocale?: string);
    defaultLocale?: string;
    protected onPrompt(context: TurnContext, state: unknown, options: PromptOptions, isRetry: boolean): Promise<void>;
    protected onRecognize(context: TurnContext, _state: unknown, _options: PromptOptions): Promise<PromptRecognizerResult<number>>;
}

// @public
export interface PathResolver {
    transformPath(path: string): string;
}

// @public
export class PercentPathResolver extends AliasPathResolver {
    constructor();
}

// @public
export abstract class Prompt<T> extends Dialog {
    protected constructor(dialogId: string, validator?: PromptValidator<T>);
    protected appendChoices(prompt: string | Activity, channelId: string, choices: (string | Choice)[], style: ListStyle, options?: ChoiceFactoryOptions): Activity;
    beginDialog(dialogContext: DialogContext, options: PromptOptions): Promise<DialogTurnResult>;
    continueDialog(dialogContext: DialogContext): Promise<DialogTurnResult>;
    protected onPreBubbleEvent(dialogContext: DialogContext, event: DialogEvent): Promise<boolean>;
    protected abstract onPrompt(context: TurnContext, state: object, options: PromptOptions, isRetry: boolean): Promise<void>;
    protected abstract onRecognize(context: TurnContext, state: object, options: PromptOptions): Promise<PromptRecognizerResult<T>>;
    repromptDialog(context: TurnContext, instance: DialogInstance): Promise<void>;
    resumeDialog(dialogContext: DialogContext, _reason: DialogReason, _result?: any): Promise<DialogTurnResult>;
}

// @public
export interface PromptCultureModel {
    inlineOr: string;
    inlineOrMore: string;
    locale: string;
    noInLanguage: string;
    separator: string;
    yesInLanguage: string;
}

// @public
export class PromptCultureModels {
    static Chinese: PromptCultureModel;
    static Dutch: PromptCultureModel;
    static English: PromptCultureModel;
    static French: PromptCultureModel;
    static German: PromptCultureModel;
    static getSupportedCultures: () => PromptCultureModel[];
    static Italian: PromptCultureModel;
    static Japanese: PromptCultureModel;
    static mapToNearestLanguage(cultureCode: string): string;
    static Portuguese: PromptCultureModel;
    static Spanish: PromptCultureModel;
}

// @public
export interface PromptOptions {
    choices?: (string | Choice)[];
    prompt?: string | Activity;
    recognizeLanguage?: string;
    retryPrompt?: string | Activity;
    style?: ListStyle;
    validations?: object;
}

// @public
export interface PromptRecognizerResult<T> {
    succeeded: boolean;
    value?: T;
}

// @public
export type PromptValidator<T> = (prompt: PromptValidatorContext<T>) => Promise<boolean>;

// @public
export interface PromptValidatorContext<T> {
    readonly attemptCount: number;
    readonly context: TurnContext;
    readonly options: PromptOptions;
    readonly recognized: PromptRecognizerResult<T>;
    readonly state: object;
}

// @public
export function recognizeChoices(utterance: string, choices: (string | Choice)[], options?: FindChoicesOptions): ModelResult<FoundChoice>[];

// @public
export class Recognizer extends Configurable implements RecognizerConfiguration {
    protected createChooseIntentResult(recognizerResults: Record<string, RecognizerResult>): RecognizerResult;
    protected fillRecognizerResultTelemetryProperties(recognizerResult: RecognizerResult, telemetryProperties: Record<string, string>, _dialogContext?: DialogContext): Record<string, string>;
    id?: string;
    recognize(_dialogContext: DialogContext, _activity: Partial<Activity>, _telemetryProperties?: Record<string, string>, _telemetryMetrics?: Record<string, number>): Promise<RecognizerResult>;
    // (undocumented)
    protected stringifyAdditionalPropertiesOfRecognizerResult(recognizerResult: RecognizerResult): string;
}

// @public
export interface RecognizerConfiguration {
    id?: string;
}

// @public
export interface RecognizerResult {
    [propName: string]: any;
    alteredText?: string;
    entities?: any;
    intents: Record<string, IntentScore>;
    text: string;
}

// @public
export function runDialog(dialog: Dialog, context: TurnContext, accessor: AgentStatePropertyAccessor<DialogState>): Promise<void>;

// @public
export class ScopePath {
    static readonly class = "class";
    static readonly conversation = "conversation";
    static readonly dialog = "dialog";
    static readonly dialogClass = "dialogClass";
    static readonly dialogContext = "dialogContext";
    static readonly settings = "settings";
    static readonly this = "this";
    static readonly turn = "turn";
    static readonly user = "user";
}

// @public
export class ServiceCollection {
    constructor(defaultServices?: Record<string, unknown>);
    addFactory<InstanceType>(key: string, factory: Factory<InstanceType, false>): this;
    addFactory<InstanceType, Dependencies>(key: string, dependencies: string[], factory: DependencyFactory<InstanceType, Dependencies, false>): this;
    addInstance<InstanceType>(key: string, instance: InstanceType): this;
    composeFactory<InstanceType>(key: string, factory: Factory<InstanceType, true>): this;
    composeFactory<InstanceType, Dependencies>(key: string, dependencies: string[], factory: DependencyFactory<InstanceType, Dependencies, true>): this;
    makeInstance<InstanceType = unknown>(key: string, deep?: boolean): InstanceType | undefined;
    makeInstances<InstancesType>(): InstancesType;
    mustMakeInstance<InstanceType = unknown>(key: string, deep?: boolean): InstanceType;
    mustMakeInstances<InstancesType extends Record<string, unknown> = Record<string, unknown>>(...keys: string[]): InstancesType;
}

// @public (undocumented)
export class SettingsMemoryScope extends MemoryScope {
    constructor(initialSettings?: Record<string, unknown>);
    getMemory(dialogContext: DialogContext): Record<string, unknown>;
    // (undocumented)
    load(dialogContext: DialogContext): Promise<void>;
    protected static loadSettings(configuration: Record<string, string>): Record<string, unknown>;
}

// @public
export interface SortedValue {
    index: number;
    value: string;
}

// @public
export interface TemplateInterface<T, D = Record<string, unknown>> {
    bind(dialogContext: DialogContext, data?: D): Promise<T>;
}

// @public
export class TextPrompt extends Prompt<string> {
    constructor(dialogId?: string, validator?: PromptValidator<string>);
    protected onPreBubbleEvent(_dc: DialogContext, _event: DialogEvent): Promise<boolean>;
    protected onPrompt(context: TurnContext, state: any, options: PromptOptions, isRetry: boolean): Promise<void>;
    protected onRecognize(context: TurnContext, _state: any, _options: PromptOptions): Promise<PromptRecognizerResult<string>>;
}

// @public (undocumented)
export class ThisMemoryScope extends MemoryScope {
    constructor();
    getMemory(dialogContext: DialogContext): object;
    setMemory(dialogContext: DialogContext, memory: object): void;
}

// @public
export interface Token {
    end: number;
    normalized: string;
    start: number;
    text: string;
}

// @public
export type TokenizerFunction = (text: string, locale?: string) => Token[];

export { TurnContext }

// @public
export class TurnMemoryScope extends MemoryScope {
    constructor();
    getMemory(dialogContext: DialogContext): object;
    setMemory(dialogContext: DialogContext, memory: object): void;
}

// @public
export class TurnPath {
    static readonly activity: string;
    static readonly activityProcessed: string;
    static readonly dialogEvent: string;
    static readonly interrupted: string;
    static readonly lastResult: string;
    static readonly recognized: string;
    static readonly recognizedEntities: string;
    static readonly repeatedIds: string;
    static readonly text: string;
    static readonly topIntent: string;
    static readonly topScore: string;
    static readonly unrecognizedText: string;
}

// @public
export class UserMemoryScope extends AgentStateMemoryScope {
    constructor();
    // (undocumented)
    protected stateKey: string;
}

// @public
export class WaterfallDialog<O extends object = {}> extends Dialog<O> {
    constructor(dialogId: string, steps?: WaterfallStep<O>[]);
    addStep(step: WaterfallStep<O>): this;
    beginDialog(dialogContext: DialogContext, options?: O): Promise<DialogTurnResult>;
    continueDialog(dialogContext: DialogContext): Promise<DialogTurnResult>;
    getVersion(): string;
    protected onStep(step: WaterfallStepContext<O>): Promise<DialogTurnResult>;
    resumeDialog(dc: DialogContext, reason: DialogReason, result?: any): Promise<DialogTurnResult>;
    protected runStep(dc: DialogContext, index: number, reason: DialogReason, result?: any): Promise<DialogTurnResult>;
}

// @public
export type WaterfallStep<O extends object = {}> = (step: WaterfallStepContext<O>) => Promise<DialogTurnResult>;

// @public
export class WaterfallStepContext<O extends object = {}> extends DialogContext {
    constructor(dialogContext: DialogContext, stepInfo: WaterfallStepInfo<O>);
    get index(): number;
    next(result?: any): Promise<DialogTurnResult>;
    get options(): O;
    get reason(): DialogReason;
    get result(): any;
    get values(): object;
}

// @public
export interface WaterfallStepInfo<O extends object> {
    index: number;
    onNext(result?: any): Promise<DialogTurnResult>;
    options: O;
    reason: DialogReason;
    result: any;
    values: object;
}

// (No @packageDocumentation comment for this package)

```
